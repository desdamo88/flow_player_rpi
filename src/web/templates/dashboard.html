{% extends "base.html" %}

{% block title %}Dashboard - Flow Player{% endblock %}

{% block content %}
<div class="dashboard">
    <div class="player-card">
        <div class="player-preview-container">
            <div class="player-preview" id="player-preview">
                <div id="preview-placeholder" class="preview-placeholder">
                    <span>S√©lectionnez une sc√®ne</span>
                </div>
                <!-- Wrapper for CSS perspective transform -->
                <div id="video-wrapper" class="video-wrapper">
                    <video id="preview-video" class="preview-video" controls loop muted>
                        Votre navigateur ne supporte pas la lecture vid√©o.
                    </video>
                </div>
            </div>
            <div class="preview-controls">
                <label class="toggle-mapping">
                    <input type="checkbox" id="show-mapping" checked onchange="toggleMappingTransform()">
                    <span>Aper√ßu d√©form√©</span>
                </label>
                <div id="mapping-info" class="mapping-info"></div>
            </div>
        </div>

        <div class="player-progress">
            <div class="progress-bar">
                <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
            </div>
            <div class="progress-time">
                <span id="time-current">00:00</span>
                <span id="time-duration">00:00</span>
            </div>
        </div>

        <div class="player-controls">
            <button id="btn-stop" class="btn btn-control" onclick="controlStop()">
                <span class="icon">&#9632;</span> STOP
            </button>
            <button id="btn-play" class="btn btn-control btn-primary" onclick="controlPlay()">
                <span class="icon">&#9654;</span> PLAY
            </button>
            <button id="btn-restart" class="btn btn-control" onclick="controlRestart()">
                <span class="icon">&#8634;</span> RESTART
            </button>
        </div>
    </div>

    <div class="project-info" id="project-info" style="display: none;">
        <div class="project-header">
            <h3 id="project-name">Projet</h3>
            <div class="project-badges">
                <span id="mapping-badge" class="badge mapping" style="display: none;">üìê Mapping actif</span>
                <span id="resolution-badge" class="badge resolution"></span>
            </div>
        </div>
    </div>

    <div class="scenes-section">
        <h3>Sc√®nes</h3>
        <div id="scenes-list" class="scenes-list">
            <p class="loading">Chargement des sc√®nes...</p>
        </div>
    </div>

    <div class="info-cards">
        <div class="info-card">
            <h3>Show actif</h3>
            <p id="show-name" class="show-name">--</p>
            <p id="show-status" class="show-status">--</p>
        </div>

        <div class="info-card">
            <h3>Sc√®ne active</h3>
            <p id="scene-name" class="scene-name">--</p>
            <p id="scene-info" class="scene-info">--</p>
        </div>

        <div class="info-card">
            <h3>Planification</h3>
            <p id="schedule-next" class="schedule-next">--</p>
            <p id="schedule-triggers" class="schedule-triggers">--</p>
        </div>

        <div class="info-card">
            <h3>DMX</h3>
            <p id="dmx-status">--</p>
            <p id="dmx-info">--</p>
        </div>

        <div class="info-card network-card">
            <h3>R√©seau</h3>
            <p id="network-ip" class="network-ip">--</p>
            <p id="network-hostname" class="network-hostname">--</p>
            <p class="network-hint">Acc√®s: <a id="network-url" href="#" target="_blank">--</a></p>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    let currentSceneId = null;
    let currentMapping = null;
    let scenesData = {};  // Store all scenes data for mapping lookup
    let mappingEnabled = true;  // Show deformed preview by default

    const videoElement = document.getElementById('preview-video');
    const videoWrapper = document.getElementById('video-wrapper');
    const placeholderElement = document.getElementById('preview-placeholder');
    const mappingInfo = document.getElementById('mapping-info');

    // Load scenes list
    async function loadScenes() {
        try {
            const response = await fetch('/api/scenes');
            const data = await response.json();

            const container = document.getElementById('scenes-list');

            // Update project info
            if (data.project && data.project.name) {
                document.getElementById('project-info').style.display = 'block';
                document.getElementById('project-name').textContent = data.project.name;

                if (data.project.resolution) {
                    document.getElementById('resolution-badge').textContent =
                        `${data.project.resolution.width}x${data.project.resolution.height}`;
                }

                // Check if any scene has mapping
                const hasAnyMapping = data.project.video_mapping?.enabled ||
                    (data.project.video_mappings && data.project.video_mappings.length > 0);

                if (hasAnyMapping) {
                    document.getElementById('mapping-badge').style.display = 'inline-block';
                }

                // Store default mapping
                if (data.project.video_mapping && data.project.video_mapping.enabled) {
                    currentMapping = data.project.video_mapping;
                    updateMappingVisualization();
                }
            }

            if (!data.scenes || data.scenes.length === 0) {
                container.innerHTML = '<p class="no-scenes">Aucune sc√®ne disponible</p>';
                return;
            }

            // Store scenes data for later lookup
            data.scenes.forEach(scene => {
                scenesData[scene.id] = scene;
            });

            currentSceneId = data.current_scene_id;

            // Update mapping for current scene if any
            if (currentSceneId && scenesData[currentSceneId]?.mapping) {
                currentMapping = scenesData[currentSceneId].mapping;
                updateMappingVisualization();
            }

            container.innerHTML = data.scenes.map(scene => {
                // Build warnings HTML
                let warningsHtml = '';
                if (scene.interactive_elements && scene.interactive_elements.length > 0) {
                    const items = scene.interactive_elements.map(e => e.type).join(', ');
                    warningsHtml += `<div class="scene-warning interactive">
                        <span class="warning-icon">‚ö†Ô∏è</span>
                        √âl√©ments interactifs non support√©s: ${items}
                    </div>`;
                }
                if (scene.unsupported_elements && scene.unsupported_elements.length > 0) {
                    const items = scene.unsupported_elements.map(e => e.type).join(', ');
                    warningsHtml += `<div class="scene-warning unsupported">
                        <span class="warning-icon">‚ùì</span>
                        √âl√©ments inconnus: ${items}
                    </div>`;
                }

                // Build content summary
                let contentParts = [];
                if (scene.video_count > 0) contentParts.push(`${scene.video_count} vid√©o`);
                if (scene.audio_count > 0) contentParts.push(`${scene.audio_count} audio`);
                if (scene.image_count > 0) contentParts.push(`${scene.image_count} image`);
                const contentSummary = contentParts.join(', ') || 'Vide';

                return `
                <div class="scene-card ${scene.is_current ? 'active' : ''} ${scene.has_warnings ? 'has-warnings' : ''}"
                     data-scene-id="${scene.id}"
                     onclick="selectScene('${scene.id}')">
                    <div class="scene-info">
                        <span class="scene-name">${scene.name}</span>
                        <span class="scene-duration">${formatTime(scene.duration_ms)}</span>
                    </div>
                    <div class="scene-meta">
                        ${scene.has_dmx ? '<span class="badge dmx">DMX: ' + (scene.dmx_sequence_name || 'Oui') + '</span>' : ''}
                        ${scene.has_mapping ? '<span class="badge mapping">Mapping</span>' : ''}
                        <span class="badge elements">${contentSummary}</span>
                    </div>
                    ${warningsHtml}
                    ${scene.is_current ? '<span class="playing-indicator">‚ñ∂ En lecture</span>' : ''}
                </div>
            `}).join('');

            // Load video for current scene if any
            if (currentSceneId) {
                loadSceneVideo(currentSceneId);
            }

        } catch (error) {
            console.error('Error loading scenes:', error);
            document.getElementById('scenes-list').innerHTML =
                '<p class="error">Erreur de chargement des sc√®nes</p>';
        }
    }

    // Select and play a scene
    async function selectScene(sceneId) {
        try {
            // Update UI immediately
            document.querySelectorAll('.scene-card').forEach(card => {
                card.classList.remove('active');
                const indicator = card.querySelector('.playing-indicator');
                if (indicator) indicator.remove();
            });

            const selectedCard = document.querySelector(`[data-scene-id="${sceneId}"]`);
            if (selectedCard) {
                selectedCard.classList.add('active');
                const indicator = document.createElement('span');
                indicator.className = 'playing-indicator';
                indicator.textContent = '‚ñ∂ En lecture';
                selectedCard.appendChild(indicator);
            }

            // Update mapping for this scene
            const sceneData = scenesData[sceneId];
            if (sceneData && sceneData.mapping && sceneData.mapping.enabled) {
                currentMapping = sceneData.mapping;
                updateMappingVisualization();
            } else if (!sceneData?.mapping) {
                // No scene-specific mapping, hide overlay if no global mapping
                if (!currentMapping) {
                    document.getElementById('show-mapping').parentElement.style.display = 'none';
                }
            }

            // Load video preview
            await loadSceneVideo(sceneId);

            // Start playback
            await apiPost(`/api/scenes/${sceneId}/play`, {loop: true});
            currentSceneId = sceneId;

        } catch (error) {
            console.error('Error selecting scene:', error);
        }
    }

    // Load video for a scene
    async function loadSceneVideo(sceneId) {
        try {
            const response = await fetch(`/api/scenes/${sceneId}/video`);
            if (!response.ok) {
                console.error('No video for scene');
                showPlaceholder('Pas de vid√©o');
                return;
            }

            const data = await response.json();

            // Show video, hide placeholder
            placeholderElement.style.display = 'none';
            videoElement.style.display = 'block';

            // Set video source
            videoElement.src = data.video_url;
            videoElement.load();
            videoElement.play().catch(e => console.log('Autoplay blocked:', e));

        } catch (error) {
            console.error('Error loading scene video:', error);
            showPlaceholder('Erreur de chargement');
        }
    }

    // Show placeholder with message
    function showPlaceholder(message) {
        placeholderElement.innerHTML = `<span>${message}</span>`;
        placeholderElement.style.display = 'flex';
        videoElement.style.display = 'none';
    }

    // Play a specific scene (legacy function)
    async function playScene(sceneId) {
        await selectScene(sceneId);
    }

    // Dashboard-specific functions
    function updateDashboard(status) {
        // Update show info
        if (status.player) {
            document.getElementById('show-name').textContent = status.player.current_show || '--';

            let stateText = status.player.state;
            if (status.player.loop_count > 0) {
                stateText += ` (boucle #${status.player.loop_count})`;
            }
            document.getElementById('show-status').textContent = stateText;

            // Update scene info
            document.getElementById('scene-name').textContent = status.player.current_scene || '--';
            document.getElementById('scene-info').textContent = status.player.state;

            // Update progress
            const progress = status.player.duration_ms > 0
                ? (status.player.position_ms / status.player.duration_ms) * 100
                : 0;
            document.getElementById('progress-fill').style.width = `${progress}%`;
            document.getElementById('time-current').textContent = formatTime(status.player.position_ms);
            document.getElementById('time-duration').textContent = formatTime(status.player.duration_ms);

            // Update play/pause button
            const btnPlay = document.getElementById('btn-play');
            if (status.player.state === 'playing') {
                btnPlay.innerHTML = '<span class="icon">&#10074;&#10074;</span> PAUSE';
                btnPlay.onclick = controlPause;
            } else {
                btnPlay.innerHTML = '<span class="icon">&#9654;</span> PLAY';
                btnPlay.onclick = controlPlay;
            }

            // Update scene cards active state
            document.querySelectorAll('.scene-card').forEach(card => {
                const isPlaying = card.querySelector('.scene-name').textContent === status.player.current_scene;
                card.classList.toggle('active', isPlaying);
            });
        }

        // Update schedule info
        if (status.schedule) {
            const nextTrigger = status.schedule.next_trigger
                ? new Date(status.schedule.next_trigger).toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})
                : '--';
            document.getElementById('schedule-next').textContent = `Prochain: ${nextTrigger}`;

            const triggers = status.schedule.triggers_today || [];
            document.getElementById('schedule-triggers').textContent =
                triggers.length > 0 ? `Aujourd'hui: ${triggers.join(', ')}` : 'Aucun declenchement';
        }

        // Update DMX info
        if (status.dmx) {
            document.getElementById('dmx-status').textContent =
                `${status.dmx.protocol.toUpperCase()} - Universe ${status.dmx.universe}`;
            document.getElementById('dmx-info').textContent =
                `${status.dmx.fps} FPS - ${status.dmx.target_ip}`;
        }
    }

    // Control functions
    async function controlPlay() {
        await apiPost('/api/control/play', {loop: true});
    }

    async function controlPause() {
        await apiPost('/api/control/pause');
    }

    async function controlStop() {
        await apiPost('/api/control/stop');
    }

    async function controlRestart() {
        await apiPost('/api/control/restart');
    }

    // Mapping visualization - Apply CSS transform to video for deformed preview
    function updateMappingVisualization() {
        if (!currentMapping || !currentMapping.enabled) {
            mappingInfo.innerHTML = '';
            document.getElementById('show-mapping').parentElement.style.display = 'none';
            resetVideoTransform();
            return;
        }

        const mode = currentMapping.mode || 'perspective';
        let infoHtml = `<strong>${mode === 'mesh' ? 'Mesh' : 'Perspective'}</strong>`;

        // Get corner points (for both perspective and mesh modes)
        let tl, tr, bl, br;

        if (mode === 'mesh' && currentMapping.mesh_grid) {
            const mesh = currentMapping.mesh_grid;
            const points = mesh.points || [];
            const rows = mesh.rows || 1;
            const cols = mesh.cols || 1;

            // Use outer corners of mesh for CSS transform approximation
            tl = points[0]?.[0] || {x: 0, y: 0};
            tr = points[0]?.[cols] || {x: 1, y: 0};
            bl = points[rows]?.[0] || {x: 0, y: 1};
            br = points[rows]?.[cols] || {x: 1, y: 1};

            // Check if corners are deformed (not at default positions)
            const cornersDeformed = (
                tl.x !== 0 || tl.y !== 0 ||
                tr.x !== 1 || tr.y !== 0 ||
                bl.x !== 0 || bl.y !== 1 ||
                br.x !== 1 || br.y !== 1
            );

            infoHtml += ` (${rows}x${cols})`;
            if (currentMapping.is_deformed) {
                infoHtml += ' <span class="badge deformed">D√©form√©</span>';
                if (!cornersDeformed) {
                    infoHtml += ' <small style="opacity:0.7">(d√©formation interne uniquement)</small>';
                }
            }
        } else {
            // Perspective mode - use direct points
            const pp = currentMapping.perspective_points || {};
            tl = pp.top_left || {x: 0, y: 0};
            tr = pp.top_right || {x: 1, y: 0};
            bl = pp.bottom_left || {x: 0, y: 1};
            br = pp.bottom_right || {x: 1, y: 1};
        }

        // Apply CSS transform if enabled
        if (mappingEnabled) {
            applyPerspectiveTransform(tl, tr, bl, br);
        } else {
            resetVideoTransform();
        }

        mappingInfo.innerHTML = infoHtml;
        document.getElementById('show-mapping').parentElement.style.display = 'flex';
    }

    // Calculate and apply CSS matrix3d transform for perspective effect
    function applyPerspectiveTransform(tl, tr, bl, br) {
        const wrapper = videoWrapper;
        if (!wrapper) return;

        // Get wrapper dimensions
        const rect = wrapper.parentElement.getBoundingClientRect();
        const w = rect.width;
        const h = rect.height;

        // Source corners (original rectangle)
        const srcPts = [
            [0, 0], [w, 0], [w, h], [0, h]
        ];

        // Destination corners (warped)
        const dstPts = [
            [tl.x * w, tl.y * h],
            [tr.x * w, tr.y * h],
            [br.x * w, br.y * h],
            [bl.x * w, bl.y * h]
        ];

        // Calculate CSS matrix3d from the 4 point correspondences
        const matrix = computePerspectiveMatrix(srcPts, dstPts);

        if (matrix) {
            wrapper.style.transform = `matrix3d(${matrix.join(',')})`;
            wrapper.style.transformOrigin = '0 0';
        }
    }

    // Compute perspective transform matrix from 4 point correspondences
    // Based on: https://franklinta.com/2014/09/08/computing-css-matrix3d-transforms/
    function computePerspectiveMatrix(srcPts, dstPts) {
        // Simplified perspective matrix calculation
        // For a more accurate result, use a proper homography calculation

        // Extract points
        const [p0s, p1s, p2s, p3s] = srcPts;
        const [p0d, p1d, p2d, p3d] = dstPts;

        // Build the adjugate matrix for the mapping
        function adj(m) {
            return [
                m[4]*m[8] - m[5]*m[7], m[2]*m[7] - m[1]*m[8], m[1]*m[5] - m[2]*m[4],
                m[5]*m[6] - m[3]*m[8], m[0]*m[8] - m[2]*m[6], m[2]*m[3] - m[0]*m[5],
                m[3]*m[7] - m[4]*m[6], m[1]*m[6] - m[0]*m[7], m[0]*m[4] - m[1]*m[3]
            ];
        }

        function multmm(a, b) {
            const c = [];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    let sum = 0;
                    for (let k = 0; k < 3; k++) {
                        sum += a[3*i + k] * b[3*k + j];
                    }
                    c[3*i + j] = sum;
                }
            }
            return c;
        }

        function multmv(m, v) {
            return [
                m[0]*v[0] + m[1]*v[1] + m[2]*v[2],
                m[3]*v[0] + m[4]*v[1] + m[5]*v[2],
                m[6]*v[0] + m[7]*v[1] + m[8]*v[2]
            ];
        }

        function basisToPoints(p0, p1, p2, p3) {
            const m = [p0[0], p1[0], p2[0], p0[1], p1[1], p2[1], 1, 1, 1];
            const v = multmv(adj(m), [p3[0], p3[1], 1]);
            return multmm(m, [v[0], 0, 0, 0, v[1], 0, 0, 0, v[2]]);
        }

        const s = basisToPoints(p0s, p1s, p2s, p3s);
        const d = basisToPoints(p0d, p1d, p2d, p3d);
        const t = multmm(d, adj(s));

        // Normalize
        for (let i = 0; i < 9; i++) t[i] = t[i] / t[8];

        // Convert 3x3 to CSS matrix3d (4x4)
        return [
            t[0], t[3], 0, t[6],
            t[1], t[4], 0, t[7],
            0,    0,    1, 0,
            t[2], t[5], 0, t[8]
        ];
    }

    function resetVideoTransform() {
        if (videoWrapper) {
            videoWrapper.style.transform = 'none';
            videoWrapper.style.transformOrigin = 'center';
        }
    }

    function toggleMappingTransform() {
        mappingEnabled = document.getElementById('show-mapping').checked;
        updateMappingVisualization();
    }

    // Load network info
    async function loadNetworkInfo() {
        try {
            const response = await fetch('/api/system/info');
            if (response.ok) {
                const data = await response.json();
                document.getElementById('network-ip').textContent = `IP: ${data.ip || 'Non disponible'}`;

                // Show hostname with .local suffix
                const hostname = data.hostname_local || data.hostname || 'Non disponible';
                document.getElementById('network-hostname').textContent = hostname;

                // Build access URLs
                const urlElement = document.getElementById('network-url');
                if (data.ip) {
                    const ipUrl = `http://${data.ip}:5000`;
                    urlElement.href = ipUrl;
                    urlElement.textContent = ipUrl;

                    // Add .local URL if available
                    if (data.hostname_local) {
                        const localUrl = `http://${data.hostname_local}:5000`;
                        urlElement.textContent = `${ipUrl} ou ${localUrl}`;
                    }
                }
            }
        } catch (error) {
            console.error('Error loading network info:', error);
        }
    }

    // Initialize
    loadScenes();
    loadNetworkInfo();
    startStatusPolling(updateDashboard);
</script>
{% endblock %}
