{% extends "base.html" %}

{% block title %}Dashboard - Flow Player{% endblock %}

{% block content %}
<div class="dashboard">
    <div class="player-card">
        <div class="player-preview-container">
            <div class="player-preview" id="player-preview">
                <div id="preview-placeholder" class="preview-placeholder">
                    <span>S√©lectionnez une sc√®ne</span>
                </div>
                <video id="preview-video" class="preview-video" controls loop muted>
                    Votre navigateur ne supporte pas la lecture vid√©o.
                </video>
                <!-- Mapping overlay -->
                <div id="mapping-overlay" class="mapping-overlay" style="display: none;">
                    <svg id="mapping-svg" class="mapping-svg" viewBox="0 0 100 100" preserveAspectRatio="none">
                        <!-- Will be populated dynamically for mesh or perspective -->
                        <g id="mapping-shapes"></g>
                        <g id="mapping-points"></g>
                    </svg>
                </div>
            </div>
            <div class="preview-controls">
                <label class="toggle-mapping">
                    <input type="checkbox" id="show-mapping" onchange="toggleMappingOverlay()">
                    <span>Afficher le mapping</span>
                </label>
                <div id="mapping-info" class="mapping-info" style="display: none;"></div>
            </div>
        </div>

        <div class="player-progress">
            <div class="progress-bar">
                <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
            </div>
            <div class="progress-time">
                <span id="time-current">00:00</span>
                <span id="time-duration">00:00</span>
            </div>
        </div>

        <div class="player-controls">
            <button id="btn-stop" class="btn btn-control" onclick="controlStop()">
                <span class="icon">&#9632;</span> STOP
            </button>
            <button id="btn-play" class="btn btn-control btn-primary" onclick="controlPlay()">
                <span class="icon">&#9654;</span> PLAY
            </button>
            <button id="btn-restart" class="btn btn-control" onclick="controlRestart()">
                <span class="icon">&#8634;</span> RESTART
            </button>
        </div>
    </div>

    <div class="project-info" id="project-info" style="display: none;">
        <div class="project-header">
            <h3 id="project-name">Projet</h3>
            <div class="project-badges">
                <span id="mapping-badge" class="badge mapping" style="display: none;">üìê Mapping actif</span>
                <span id="resolution-badge" class="badge resolution"></span>
            </div>
        </div>
    </div>

    <div class="scenes-section">
        <h3>Sc√®nes</h3>
        <div id="scenes-list" class="scenes-list">
            <p class="loading">Chargement des sc√®nes...</p>
        </div>
    </div>

    <div class="info-cards">
        <div class="info-card">
            <h3>Show actif</h3>
            <p id="show-name" class="show-name">--</p>
            <p id="show-status" class="show-status">--</p>
        </div>

        <div class="info-card">
            <h3>Sc√®ne active</h3>
            <p id="scene-name" class="scene-name">--</p>
            <p id="scene-info" class="scene-info">--</p>
        </div>

        <div class="info-card">
            <h3>Planification</h3>
            <p id="schedule-next" class="schedule-next">--</p>
            <p id="schedule-triggers" class="schedule-triggers">--</p>
        </div>

        <div class="info-card">
            <h3>DMX</h3>
            <p id="dmx-status">--</p>
            <p id="dmx-info">--</p>
        </div>

        <div class="info-card network-card">
            <h3>R√©seau</h3>
            <p id="network-ip" class="network-ip">--</p>
            <p id="network-hostname" class="network-hostname">--</p>
            <p class="network-hint">Acc√®s: <a id="network-url" href="#" target="_blank">--</a></p>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    let currentSceneId = null;
    let currentMapping = null;
    let scenesData = {};  // Store all scenes data for mapping lookup
    const videoElement = document.getElementById('preview-video');
    const placeholderElement = document.getElementById('preview-placeholder');
    const mappingOverlay = document.getElementById('mapping-overlay');
    const mappingInfo = document.getElementById('mapping-info');

    // Load scenes list
    async function loadScenes() {
        try {
            const response = await fetch('/api/scenes');
            const data = await response.json();

            const container = document.getElementById('scenes-list');

            // Update project info
            if (data.project && data.project.name) {
                document.getElementById('project-info').style.display = 'block';
                document.getElementById('project-name').textContent = data.project.name;

                if (data.project.resolution) {
                    document.getElementById('resolution-badge').textContent =
                        `${data.project.resolution.width}x${data.project.resolution.height}`;
                }

                // Check if any scene has mapping
                const hasAnyMapping = data.project.video_mapping?.enabled ||
                    (data.project.video_mappings && data.project.video_mappings.length > 0);

                if (hasAnyMapping) {
                    document.getElementById('mapping-badge').style.display = 'inline-block';
                }

                // Store default mapping
                if (data.project.video_mapping && data.project.video_mapping.enabled) {
                    currentMapping = data.project.video_mapping;
                    updateMappingVisualization();
                }
            }

            if (!data.scenes || data.scenes.length === 0) {
                container.innerHTML = '<p class="no-scenes">Aucune sc√®ne disponible</p>';
                return;
            }

            // Store scenes data for later lookup
            data.scenes.forEach(scene => {
                scenesData[scene.id] = scene;
            });

            currentSceneId = data.current_scene_id;

            // Update mapping for current scene if any
            if (currentSceneId && scenesData[currentSceneId]?.mapping) {
                currentMapping = scenesData[currentSceneId].mapping;
                updateMappingVisualization();
            }

            container.innerHTML = data.scenes.map(scene => {
                // Build warnings HTML
                let warningsHtml = '';
                if (scene.interactive_elements && scene.interactive_elements.length > 0) {
                    const items = scene.interactive_elements.map(e => e.type).join(', ');
                    warningsHtml += `<div class="scene-warning interactive">
                        <span class="warning-icon">‚ö†Ô∏è</span>
                        √âl√©ments interactifs non support√©s: ${items}
                    </div>`;
                }
                if (scene.unsupported_elements && scene.unsupported_elements.length > 0) {
                    const items = scene.unsupported_elements.map(e => e.type).join(', ');
                    warningsHtml += `<div class="scene-warning unsupported">
                        <span class="warning-icon">‚ùì</span>
                        √âl√©ments inconnus: ${items}
                    </div>`;
                }

                // Build content summary
                let contentParts = [];
                if (scene.video_count > 0) contentParts.push(`${scene.video_count} vid√©o`);
                if (scene.audio_count > 0) contentParts.push(`${scene.audio_count} audio`);
                if (scene.image_count > 0) contentParts.push(`${scene.image_count} image`);
                const contentSummary = contentParts.join(', ') || 'Vide';

                return `
                <div class="scene-card ${scene.is_current ? 'active' : ''} ${scene.has_warnings ? 'has-warnings' : ''}"
                     data-scene-id="${scene.id}"
                     onclick="selectScene('${scene.id}')">
                    <div class="scene-info">
                        <span class="scene-name">${scene.name}</span>
                        <span class="scene-duration">${formatTime(scene.duration_ms)}</span>
                    </div>
                    <div class="scene-meta">
                        ${scene.has_dmx ? '<span class="badge dmx">DMX: ' + (scene.dmx_sequence_name || 'Oui') + '</span>' : ''}
                        ${scene.has_mapping ? '<span class="badge mapping">Mapping</span>' : ''}
                        <span class="badge elements">${contentSummary}</span>
                    </div>
                    ${warningsHtml}
                    ${scene.is_current ? '<span class="playing-indicator">‚ñ∂ En lecture</span>' : ''}
                </div>
            `}).join('');

            // Load video for current scene if any
            if (currentSceneId) {
                loadSceneVideo(currentSceneId);
            }

        } catch (error) {
            console.error('Error loading scenes:', error);
            document.getElementById('scenes-list').innerHTML =
                '<p class="error">Erreur de chargement des sc√®nes</p>';
        }
    }

    // Select and play a scene
    async function selectScene(sceneId) {
        try {
            // Update UI immediately
            document.querySelectorAll('.scene-card').forEach(card => {
                card.classList.remove('active');
                const indicator = card.querySelector('.playing-indicator');
                if (indicator) indicator.remove();
            });

            const selectedCard = document.querySelector(`[data-scene-id="${sceneId}"]`);
            if (selectedCard) {
                selectedCard.classList.add('active');
                const indicator = document.createElement('span');
                indicator.className = 'playing-indicator';
                indicator.textContent = '‚ñ∂ En lecture';
                selectedCard.appendChild(indicator);
            }

            // Update mapping for this scene
            const sceneData = scenesData[sceneId];
            if (sceneData && sceneData.mapping && sceneData.mapping.enabled) {
                currentMapping = sceneData.mapping;
                updateMappingVisualization();
            } else if (!sceneData?.mapping) {
                // No scene-specific mapping, hide overlay if no global mapping
                if (!currentMapping) {
                    document.getElementById('show-mapping').parentElement.style.display = 'none';
                }
            }

            // Load video preview
            await loadSceneVideo(sceneId);

            // Start playback
            await apiPost(`/api/scenes/${sceneId}/play`, {loop: true});
            currentSceneId = sceneId;

        } catch (error) {
            console.error('Error selecting scene:', error);
        }
    }

    // Load video for a scene
    async function loadSceneVideo(sceneId) {
        try {
            const response = await fetch(`/api/scenes/${sceneId}/video`);
            if (!response.ok) {
                console.error('No video for scene');
                showPlaceholder('Pas de vid√©o');
                return;
            }

            const data = await response.json();

            // Show video, hide placeholder
            placeholderElement.style.display = 'none';
            videoElement.style.display = 'block';

            // Set video source
            videoElement.src = data.video_url;
            videoElement.load();
            videoElement.play().catch(e => console.log('Autoplay blocked:', e));

        } catch (error) {
            console.error('Error loading scene video:', error);
            showPlaceholder('Erreur de chargement');
        }
    }

    // Show placeholder with message
    function showPlaceholder(message) {
        placeholderElement.innerHTML = `<span>${message}</span>`;
        placeholderElement.style.display = 'flex';
        videoElement.style.display = 'none';
    }

    // Play a specific scene (legacy function)
    async function playScene(sceneId) {
        await selectScene(sceneId);
    }

    // Dashboard-specific functions
    function updateDashboard(status) {
        // Update show info
        if (status.player) {
            document.getElementById('show-name').textContent = status.player.current_show || '--';

            let stateText = status.player.state;
            if (status.player.loop_count > 0) {
                stateText += ` (boucle #${status.player.loop_count})`;
            }
            document.getElementById('show-status').textContent = stateText;

            // Update scene info
            document.getElementById('scene-name').textContent = status.player.current_scene || '--';
            document.getElementById('scene-info').textContent = status.player.state;

            // Update progress
            const progress = status.player.duration_ms > 0
                ? (status.player.position_ms / status.player.duration_ms) * 100
                : 0;
            document.getElementById('progress-fill').style.width = `${progress}%`;
            document.getElementById('time-current').textContent = formatTime(status.player.position_ms);
            document.getElementById('time-duration').textContent = formatTime(status.player.duration_ms);

            // Update play/pause button
            const btnPlay = document.getElementById('btn-play');
            if (status.player.state === 'playing') {
                btnPlay.innerHTML = '<span class="icon">&#10074;&#10074;</span> PAUSE';
                btnPlay.onclick = controlPause;
            } else {
                btnPlay.innerHTML = '<span class="icon">&#9654;</span> PLAY';
                btnPlay.onclick = controlPlay;
            }

            // Update scene cards active state
            document.querySelectorAll('.scene-card').forEach(card => {
                const isPlaying = card.querySelector('.scene-name').textContent === status.player.current_scene;
                card.classList.toggle('active', isPlaying);
            });
        }

        // Update schedule info
        if (status.schedule) {
            const nextTrigger = status.schedule.next_trigger
                ? new Date(status.schedule.next_trigger).toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})
                : '--';
            document.getElementById('schedule-next').textContent = `Prochain: ${nextTrigger}`;

            const triggers = status.schedule.triggers_today || [];
            document.getElementById('schedule-triggers').textContent =
                triggers.length > 0 ? `Aujourd'hui: ${triggers.join(', ')}` : 'Aucun declenchement';
        }

        // Update DMX info
        if (status.dmx) {
            document.getElementById('dmx-status').textContent =
                `${status.dmx.protocol.toUpperCase()} - Universe ${status.dmx.universe}`;
            document.getElementById('dmx-info').textContent =
                `${status.dmx.fps} FPS - ${status.dmx.target_ip}`;
        }
    }

    // Control functions
    async function controlPlay() {
        await apiPost('/api/control/play', {loop: true});
    }

    async function controlPause() {
        await apiPost('/api/control/pause');
    }

    async function controlStop() {
        await apiPost('/api/control/stop');
    }

    async function controlRestart() {
        await apiPost('/api/control/restart');
    }

    // Mapping visualization functions
    function updateMappingVisualization() {
        const shapesGroup = document.getElementById('mapping-shapes');
        const pointsGroup = document.getElementById('mapping-points');

        if (!currentMapping || !currentMapping.enabled) {
            mappingOverlay.style.display = 'none';
            mappingInfo.style.display = 'none';
            document.getElementById('show-mapping').parentElement.style.display = 'none';
            return;
        }

        // Clear previous content
        shapesGroup.innerHTML = '';
        pointsGroup.innerHTML = '';

        const mode = currentMapping.mode || 'perspective';
        let infoHtml = `<strong>Mode:</strong> ${mode}`;

        if (mode === 'mesh' && currentMapping.mesh_grid) {
            // Render mesh grid
            const mesh = currentMapping.mesh_grid;
            const points = mesh.points || [];
            const rows = mesh.rows || 1;
            const cols = mesh.cols || 1;

            infoHtml += ` (${rows}x${cols} cellules)`;

            // Draw mesh cells
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (points[r] && points[r+1]) {
                        const p1 = points[r][c] || {x: c/cols, y: r/rows};
                        const p2 = points[r][c+1] || {x: (c+1)/cols, y: r/rows};
                        const p3 = points[r+1][c+1] || {x: (c+1)/cols, y: (r+1)/rows};
                        const p4 = points[r+1][c] || {x: c/cols, y: (r+1)/rows};

                        const polygonPoints = [
                            `${p1.x * 100},${p1.y * 100}`,
                            `${p2.x * 100},${p2.y * 100}`,
                            `${p3.x * 100},${p3.y * 100}`,
                            `${p4.x * 100},${p4.y * 100}`
                        ].join(' ');

                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', polygonPoints);
                        polygon.setAttribute('class', 'mapping-cell');
                        shapesGroup.appendChild(polygon);
                    }
                }
            }

            // Draw grid points
            for (let r = 0; r < points.length; r++) {
                for (let c = 0; c < (points[r] || []).length; c++) {
                    const p = points[r][c];
                    if (p) {
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', p.x * 100);
                        circle.setAttribute('cy', p.y * 100);
                        circle.setAttribute('r', '2');
                        circle.setAttribute('class', 'mapping-point');

                        // Check if deformed (not at expected position)
                        const expectedX = c / cols;
                        const expectedY = r / rows;
                        if (Math.abs(p.x - expectedX) > 0.01 || Math.abs(p.y - expectedY) > 0.01) {
                            circle.setAttribute('class', 'mapping-point deformed');
                            circle.setAttribute('r', '3');
                        }
                        pointsGroup.appendChild(circle);
                    }
                }
            }

            if (currentMapping.is_deformed) {
                infoHtml += ' <span class="badge deformed">D√©form√©</span>';
            }

        } else {
            // Render perspective (4 corners)
            const pp = currentMapping.perspective_points || {};
            const tl = pp.top_left || {x: 0, y: 0};
            const tr = pp.top_right || {x: 1, y: 0};
            const bl = pp.bottom_left || {x: 0, y: 1};
            const br = pp.bottom_right || {x: 1, y: 1};

            const polygonPoints = [
                `${tl.x * 100},${tl.y * 100}`,
                `${tr.x * 100},${tr.y * 100}`,
                `${br.x * 100},${br.y * 100}`,
                `${bl.x * 100},${bl.y * 100}`
            ].join(' ');

            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', polygonPoints);
            polygon.setAttribute('class', 'mapping-shape');
            shapesGroup.appendChild(polygon);

            // Draw corner points
            const corners = [
                {p: tl, label: 'TL'},
                {p: tr, label: 'TR'},
                {p: bl, label: 'BL'},
                {p: br, label: 'BR'}
            ];

            corners.forEach(c => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', c.p.x * 100);
                circle.setAttribute('cy', c.p.y * 100);
                circle.setAttribute('r', '3');
                circle.setAttribute('class', 'mapping-corner');
                pointsGroup.appendChild(circle);
            });

            infoHtml += `<br><small>
                TL: (${(tl.x*100).toFixed(1)}%, ${(tl.y*100).toFixed(1)}%) |
                TR: (${(tr.x*100).toFixed(1)}%, ${(tr.y*100).toFixed(1)}%)<br>
                BL: (${(bl.x*100).toFixed(1)}%, ${(bl.y*100).toFixed(1)}%) |
                BR: (${(br.x*100).toFixed(1)}%, ${(br.y*100).toFixed(1)}%)
            </small>`;
        }

        if (currentMapping.target_resolution) {
            const res = currentMapping.target_resolution;
            infoHtml += `<br><small>Cible: ${res.width}x${res.height}</small>`;
        }

        mappingInfo.innerHTML = infoHtml;
        mappingInfo.style.display = 'block';
        document.getElementById('show-mapping').parentElement.style.display = 'flex';
    }

    function toggleMappingOverlay() {
        const show = document.getElementById('show-mapping').checked;
        if (show && currentMapping) {
            mappingOverlay.style.display = 'block';
        } else {
            mappingOverlay.style.display = 'none';
        }
    }

    // Load network info
    async function loadNetworkInfo() {
        try {
            const response = await fetch('/api/system/info');
            if (response.ok) {
                const data = await response.json();
                document.getElementById('network-ip').textContent = `IP: ${data.ip || 'Non disponible'}`;

                // Show hostname with .local suffix
                const hostname = data.hostname_local || data.hostname || 'Non disponible';
                document.getElementById('network-hostname').textContent = hostname;

                // Build access URLs
                const urlElement = document.getElementById('network-url');
                if (data.ip) {
                    const ipUrl = `http://${data.ip}:5000`;
                    urlElement.href = ipUrl;
                    urlElement.textContent = ipUrl;

                    // Add .local URL if available
                    if (data.hostname_local) {
                        const localUrl = `http://${data.hostname_local}:5000`;
                        urlElement.textContent = `${ipUrl} ou ${localUrl}`;
                    }
                }
            }
        } catch (error) {
            console.error('Error loading network info:', error);
        }
    }

    // Initialize
    loadScenes();
    loadNetworkInfo();
    startStatusPolling(updateDashboard);
</script>
{% endblock %}
